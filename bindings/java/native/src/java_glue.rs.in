use std::{
    path::{Path, PathBuf},
    time::Duration,
    str::FromStr,
};

use chrono::prelude::{DateTime, Utc, Local};

use crate::{
    jni_c_header::*,
    client_options::*,
    bee_types::*,
    acc::*,
    sync::*,
    acc_manager::*,
    message::*,
    address::*
};

use anyhow::Result as Result;

use log::debug;

use iota_wallet::{
    account::{
        AccountBalance,
    },
    message::{
        MessageType, Value, ValueUnit, MessageId
    },
    address::{
        OutputKind, AddressWrapper
    },
    client::{
        Api,
    }
};

foreign_class!(class RustLogging {
    fn init() {
        env_logger::init();
    }
});

foreign_enum!(
    enum RemainderValueStrategy {
        ReuseAddress = RemainderValueStrategy::ReuseAddress,
        ChangeAddress = RemainderValueStrategy::ChangeAddress,
    }
);

foreign_enum!(
    enum ManagerStorage {
        Stronghold = ManagerStorage::Stronghold,
        Sqlite = ManagerStorage::Sqlite,
    }
);

foreign_enum!(
    enum AccountSignerType {
        Stronghold = AccountSignerType::Stronghold,
        LedgerNano = AccountSignerType::LedgerNano,
        LedgerNanoSimulator = AccountSignerType::LedgerNanoSimulator,
    }
);

foreign_enum!(
    enum Api {
        GetTips = Api::GetTips,
        PostMessage = Api::PostMessage,
        GetOutput = Api::GetOutput,
    }
);

foreign_enum!(
    enum MessageType {
        Received = MessageType::Received,
        Sent = MessageType::Sent,
        Failed = MessageType::Failed,
        Unconfirmed = MessageType::Unconfirmed,
        Value = MessageType::Value,
    }
);

foreign_enum!(
    enum ValueUnit {
        I = ValueUnit::I,
        Ki = ValueUnit::Ki,
        Mi = ValueUnit::Mi,
        Gi = ValueUnit::Gi,
        Ti = ValueUnit::Ti,
        Pi = ValueUnit::Pi,
    }
);

foreign_enum!(
    enum OutputKind {
        SignatureLockedSingle = OutputKind::SignatureLockedSingle,
        SignatureLockedDustAllowance = OutputKind::SignatureLockedDustAllowance,
        Treasury = OutputKind::Treasury,
    }
);

foreign_class!(class ManagerOptions {
    self_type ManagerOptions;
    constructor ManagerOptions::default() -> ManagerOptions;
    fn ManagerOptions::setStoragePath(&mut self, storage_path: PathBuf);
    fn ManagerOptions::setStorageType(&mut self, storage_type: ManagerStorage);
    fn ManagerOptions::setStoragePassword(&mut self, storage_password: String);
});

foreign_class!(class AccountManager {
    self_type AccountManager;
    constructor AccountManager::new(options: ManagerOptions) -> AccountManager;
    fn AccountManager::stopBackgroundSync(&mut self,) -> Result<()>;
    fn AccountManager::setStoragePassword(&mut self, password: &str) -> Result<()>;
    fn AccountManager::setStrongholdPassword(&mut self, password: &str) -> Result<()>;
    fn AccountManager::changeStrongholdPassword(&mut self, current_password: &str, new_password: &str) -> Result<()>;
    fn AccountManager::generateMnemonic(&mut self) -> Result<String>;
    fn AccountManager::storeMnemonic(&mut self, signer_type_enum: AccountSignerType, mnemonic: String) -> Result<()>;
    fn AccountManager::verify_mnemonic(&mut self, mnemonic: String) -> Result<()>;
    fn AccountManager::create_account(&mut self, client_options: ClientOptions) -> Result<AccountInitialiser>;
});

foreign_class!(class ClientOptionsBuilder {
    self_type ClientOptionsBuilder;
    constructor ClientOptionsBuilder::new() -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_node(&mut self, node: &str) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_node_pool_urls(&mut self, node_pool_urls: Vec<String>) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_network(&mut self, network: String) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_node_sync_interval(&mut self, node_sync_interval: Duration) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_node_sync_disabled(&mut self) -> ClientOptionsBuilder;
    //fn ClientOptionsBuilder::with_mqtt_mqtt_broker_options(&mut self, options: BrokerOptions) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_local_pow(&mut self, local: bool) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_request_timeout(&mut self, timeout: Duration) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_api_timeout(&mut self, api: Api, timeout: Duration) -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::build(&mut self) -> Result<ClientOptions>;
});

foreign_class!(class ClientOptions{
    self_type ClientOptions;
    private constructor = empty;
});

foreign_class!(
    class Value {
        self_type Value;
        constructor Value::new(value: u64, unit: ValueUnit) -> Value;
        fn Value::with_denomination(&self) -> String;
        fn Value::without_denomination(&self) -> u64;
        fn Value::value(&self) -> &u64;
    }
);
foreign_class!(
    class MessageId {
        self_type MessageId;
        fn MessageId::fromString(str_rep: &str) -> MessageId {
            MessageId::from_str(str_rep).unwrap()
        }
        constructor MessageId::null() -> MessageId;
    }
);

foreign_class!(
    #[derive(PartialEq)]
    class Message {
        self_type Message;
        private constructor = empty;
        private fn Message::eq(&self, o: &Message) -> bool; alias rustEq;
        fn Message::id(&self) -> MessageId;
        fn Message::version(&self) -> u64;
        fn Message::parents(&self) -> Vec<MessageId>;
        fn Message::payload_length(&self) -> usize;
        fn Message::payload(&self) -> Option<MessagePayload>;
        fn Message::timestamp(&self) -> DateTime<Utc>;
        fn Message::nonce(&self) -> u64;
        fn Message::confirmed(&self) -> Option<bool>;
        fn Message::broadcasted(&self) -> bool;
        fn Message::incoming(&self) -> bool;
        fn Message::value(&self) -> u64;
        fn Message::remainder_value(&self) -> u64;
    }
);

foreign_class!(
    class MessagePayload {
        self_type MessagePayload;
        private constructor = empty;
    }
);

foreign_class!(
    class IndexationPayload {
        self_type IndexationPayload;
        private constructor = empty;
    }
);
foreign_class!(
    #[derive(PartialEq)]
    class Address {
        self_type Address;
        private constructor = empty;
        private fn Address::eq(&self, o: &Address) -> bool; alias rustEq;
        fn Address::balance(&self) -> u64; alias getBalance;
        fn Address::readable(&self) -> String; alias getReadable;
        fn Address::address(&self) -> AddressWrapper;
    }
);

foreign_class!(
    class AddressWrapper {
        self_type AddressWrapper;
        private constructor = empty;
        fn AddressWrapper::to_bech32(&self) -> String; alias toBech32;
    }
);

foreign_class!(
    class AccountInitialiser{
        self_type AccountInitialiser;
        private constructor = empty;

        fn AccountInitialiser::signer_type(&mut self, signer_type_enum: AccountSignerType) -> AccountInitialiser;
        fn AccountInitialiser::alias(&mut self, alias: String) -> AccountInitialiser;
        fn AccountInitialiser::created_at(&mut self, created_at: DateTime<Local>) -> AccountInitialiser;
        fn AccountInitialiser::messages(&mut self, messages: Vec<Message>) -> AccountInitialiser;
        fn AccountInitialiser::addresses(&mut self, addresses: Vec<Address>) -> AccountInitialiser;
        fn AccountInitialiser::skip_persistance(&mut self) -> AccountInitialiser;
        fn AccountInitialiser::initialise(&mut self) -> Result<Account>;
    }
);

foreign_class!(
    class AccountBalance {
        self_type AccountBalance;
        private constructor = empty;
        fn AccountBalance::getTotal(&self) -> u64 {
            this.total
        }
        fn AccountBalance::getAvailable(&self) -> u64 {
            this.available
        }
        fn AccountBalance::getIncoming(&self) -> u64 {
            this.incoming
        }
        fn AccountBalance::getOutgoing(&self) -> u64 {
            this.outgoing
        }
    }
);

foreign_class!(
    class Account {
        self_type Account;
        private constructor = empty;
        fn Account::sync(&self) -> AccountSynchronizer;
        fn Account::generate_address(&self) -> Result<Address>;
        fn Account::get_unused_address(&self) -> Result<Address>;
        //fn Account::is_latest_address_unused(&self) -> Result<bool>;
        fn Account::latest_address(&self) -> Address;
        fn Account::set_alias(&self, alias: String) -> Result<()>;
        fn Account::set_client_options(&self, options: ClientOptions) -> Result<()>;
        fn Account::list_messages(&self, count: usize, from: usize, message_type: Option<MessageType>) -> Vec<Message>;
        fn Account::list_spent_addresses(&self) -> Vec<Address>;
        fn Account::list_unspent_addresses(&self) -> Vec<Address>;
        fn Account::get_message(&self, message_id: MessageId) -> Option<Message>;
        fn Account::alias(&self) -> String;
        fn Account::balance(&self) -> AccountBalance;
    }
);

foreign_class!(
    class AccountSynchronizer {
        self_type AccountSynchronizer;
        private constructor = empty;

        fn AccountSynchronizer::gap_limit(&mut self, limit: usize) -> AccountSynchronizer;
        fn AccountSynchronizer::skip_persistance(&mut self) -> AccountSynchronizer;
        fn AccountSynchronizer::address_index(&mut self, address_index: usize) -> AccountSynchronizer;
        fn AccountSynchronizer::execute(&mut self) -> Result<SyncedAccount>;
    }
);

foreign_class!(
    class SyncedAccount {
        self_type SyncedAccount;
        private constructor = empty;

        fn SyncedAccount::deposit_address(&mut self) -> Address;
        fn SyncedAccount::transfer(&mut self, transfer: Transfer) -> Result<Message>;
    }
);

foreign_class!(
    class Transfer {
        self_type Transfer;
        private constructor = empty;
        fn Transfer::builder(address: AddressWrapper, amount: u64) -> TransferBuilder;
    }
);

foreign_class!(
    class TransferBuilder {
        self_type TransferBuilder;
        constructor TransferBuilder::new(address: AddressWrapper, amount: u64) -> TransferBuilder;
        fn TransferBuilder::with_remainder_value_strategy(&mut self, strategy: RemainderValueStrategy) -> TransferBuilder;
        fn TransferBuilder::with_indexation(&mut self, indexation: IndexationPayload) -> TransferBuilder;
        fn TransferBuilder::finish(&self) -> Transfer;
    }
);
