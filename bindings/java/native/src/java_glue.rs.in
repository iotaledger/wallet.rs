use std::{
    path::PathBuf,
    time::Duration,
    str::FromStr,
};

use chrono::prelude::{
    DateTime, Utc, Local
};

use crate::{
    jni_c_header::*,
    bee_types::*,
    acc::*,
    client_options::*,
    acc_manager::*,
    event_manager::*,
    message::*,
    address::*,
};

use anyhow::{
    Result as Result,
    anyhow,
};

use iota_wallet::{
    account::{
        AccountBalance,
    },
    message::{
        MessageType, Value, ValueUnit, MessageId
    },
    address::{
        OutputKind, AddressWrapper
    },
    client::{
        Api,
    },
    event::{
        EventId, TransferProgressType, BalanceChange,
        TransactionEvent as WalletTransactionEvent,
        TransactionConfirmationChangeEvent as WalletTransactionConfirmationChangeEvent,
        AddressConsolidationNeeded as WalletAddressConsolidationNeeded,
        TransferProgress as WalletTransferProgress,
        BalanceEvent as WalletBalanceEvent,
    },
};

use iota::{
    SignatureLockedSingleOutput,
};

foreign_class!(class RustLogging {
    fn init() {
        env_logger::init();
    }
});

foreign_enum!(
    enum RemainderValueStrategy {
        REUSE_ADDRESS = RemainderValueStrategy::ReuseAddress,
        CHANGE_ADDRESS = RemainderValueStrategy::ChangeAddress,
    }
);

foreign_enum!(
    enum ManagerStorage {
        STRONGHOLD = ManagerStorage::Stronghold,
        SQLITE = ManagerStorage::Sqlite,
    }
);

foreign_enum!(
    enum AccountSignerType {
        STRONGHOLD = AccountSignerType::Stronghold,
        LEDGER_NANO = AccountSignerType::LedgerNano,
        LEDGER_NANO_SIMULATOR = AccountSignerType::LedgerNanoSimulator,
    }
);

foreign_enum!(
    enum Api {
        GET_TIPS = Api::GetTips,
        POST_MESSAGE = Api::PostMessage,
        GET_OUTPUT = Api::GetOutput,
    }
);

foreign_enum!(
    enum MessageType {
        RECEIVED = MessageType::Received,
        SENT = MessageType::Sent,
        FAILED = MessageType::Failed,
        UNCONFIRMED = MessageType::Unconfirmed,
        VALUE = MessageType::Value,
    }
);

foreign_enum!(
    enum MessagePayloadType {
        TRANSACTION = MessagePayloadType::Transaction,
        MILESTONE = MessagePayloadType::Milestone,
        INDEXATION = MessagePayloadType::Indexation,
        RECEIPT = MessagePayloadType::Receipt,
        TREASURY_TRANSACTION = MessagePayloadType::TreasuryTransaction,
    }
);

foreign_enum!(
    enum ValueUnit {
        I = ValueUnit::I,
        Ki = ValueUnit::Ki,
        Mi = ValueUnit::Mi,
        Gi = ValueUnit::Gi,
        Ti = ValueUnit::Ti,
        Pi = ValueUnit::Pi,
    }
);

foreign_enum!(
    enum OutputKind {
        SIGNATURE_LOCKED_SINGLE = OutputKind::SignatureLockedSingle,
        SIGNATURE_LOCKED_DUST_ALLOWANCE = OutputKind::SignatureLockedDustAllowance,
        TREASURY = OutputKind::Treasury,
    }
);

foreign_enum!(
    enum InputKind {
        UTXO = InputKind::UTXO,
        TREASURY = InputKind::Treasury,
    }
);
foreign_enum!(
    enum UnlockBlockKind {
        ED25519 = UnlockBlockKind::Ed25519,
        REFERENCE = UnlockBlockKind::Reference,
    }
);

foreign_class!(class RustHex {
    fn hex::encode(_ : String) -> String;
    fn decode(s : String) -> Result<Vec<u8>> {
        let res = hex::decode(s);
        match res {
            Ok(s) => Ok(s),
            Err(e) => Err(anyhow!("Hex error {:?}", e.to_string()))
        }
    }
});

foreign_class!(class ManagerOptions {
    self_type ManagerOptions;
    constructor ManagerOptions::default() -> ManagerOptions;
    fn ManagerOptions::set_storage_path(&mut self, storage_path: PathBuf); alias setStoragePath;
    fn ManagerOptions::set_storage_type(&mut self, storage_type: ManagerStorage); alias setStorageType;
    fn ManagerOptions::set_storage_password(&mut self, storage_password: String); alias setStoragePassword;
});

foreign_class!(class AccountManager {
    self_type AccountManager;
    constructor AccountManager::new(options: ManagerOptions) -> AccountManager;
    fn AccountManager::stop_background_sync(&mut self,) -> Result<()>; alias stopBackgroundSync;
    fn AccountManager::set_storage_password(&mut self, password: &str) -> Result<()>; alias setStoragePassword;
    fn AccountManager::set_stronghold_password(&mut self, password: &str) -> Result<()>; alias setStrongholdPassword;
    fn AccountManager::change_stronghold_password(&mut self, current_password: &str, new_password: &str) -> Result<()>; alias changeStrongholdPassword;
    fn AccountManager::generate_mnemonic(&mut self) -> Result<String>; alias generateMnemonic;
    fn AccountManager::store_mnemonic(&mut self, signer_type_enum: AccountSignerType, mnemonic: String) -> Result<()>; alias storeMnemonic;
    fn AccountManager::verify_mnemonic(&mut self, mnemonic: String) -> Result<()>; alias verifyMnemonic;
    fn AccountManager::create_account(&mut self, client_options: ClientOptions) -> Result<AccountInitialiser>; alias createAccount;
    fn AccountManager::remove_account(&self, account_id: String) -> Result<()>; alias removeAccount;
    fn AccountManager::get_account(&self, account_id: String) -> Result<Account>; alias getAccount;
    fn AccountManager::get_accounts(&self) -> Result<Vec<Account>>; alias getAccounts;
    fn AccountManager::reattach(&self, account_id: String, message_id: MessageId) -> Result<Message>;
    fn AccountManager::promote(&self, account_id: String, message_id: MessageId) -> Result<Message>; 
    fn AccountManager::retry(&self, account_id: String, message_id: MessageId) -> Result<Message>;
    fn AccountManager::internal_transfer(&self, from_account_id: String, to_account_id: String, amount: u64) -> Result<Message>; alias internalTransfer;
    fn AccountManager::backup(&self, destination: PathBuf) -> Result<PathBuf>;
    fn AccountManager::import_accounts(&mut self, source: PathBuf, stronghold_password: String) -> Result<()>; alias importAccounts;
});

foreign_class!(class BrokerOptions {
    self_type BrokerOptions;
    constructor BrokerOptions::new() -> BrokerOptions;
    fn BrokerOptions::automatic_disconnect(&self, disconnect: bool) -> BrokerOptions; alias automaticDisconnect;
    fn BrokerOptions::timeout(&self, timeout: Duration) -> BrokerOptions;
    fn BrokerOptions::use_ws(&self, use_ws: bool) -> BrokerOptions; alias useWebSockets;
});

foreign_class!(class ClientOptionsBuilder {
    self_type ClientOptionsBuilder;
    constructor ClientOptionsBuilder::new() -> ClientOptionsBuilder;
    fn ClientOptionsBuilder::with_node(&mut self, node: &str) -> ClientOptionsBuilder; alias withNode;
    fn ClientOptionsBuilder::with_node_pool_urls(&mut self, node_pool_urls: Vec<String>) -> ClientOptionsBuilder; alias withNodePoolUrls;
    fn ClientOptionsBuilder::with_network(&mut self, network: String) -> ClientOptionsBuilder; alias withNetwork;
    fn ClientOptionsBuilder::with_node_sync_interval(&mut self, node_sync_interval: Duration) -> ClientOptionsBuilder; alias withNodeSyncInterval;
    fn ClientOptionsBuilder::with_node_sync_disabled(&mut self) -> ClientOptionsBuilder; alias withNodeSyncDisabled;
    fn ClientOptionsBuilder::with_mqtt_mqtt_broker_options(&mut self, options: BrokerOptions) -> ClientOptionsBuilder; alias withMqttBrokerOptions;
    fn ClientOptionsBuilder::with_local_pow(&mut self, local: bool) -> ClientOptionsBuilder; alias withLocalPow;
    fn ClientOptionsBuilder::with_request_timeout(&mut self, timeout: Duration) -> ClientOptionsBuilder; alias withRequestTimeout;
    fn ClientOptionsBuilder::with_api_timeout(&mut self, api: Api, timeout: Duration) -> ClientOptionsBuilder; alias withApiTimeout;
    fn ClientOptionsBuilder::build(&mut self) -> Result<ClientOptions>;
});

foreign_class!(class ClientOptions{
    self_type ClientOptions;
    private constructor = empty;
});

foreign_class!(
    #[derive(Display)]
    class Value {
        self_type Value;
        constructor Value::new(value: u64, unit: ValueUnit) -> Value;
        private fn Value::with_denomination(&self) -> String; alias to_string;
        fn Value::with_denomination(&self) -> String; alias withDenomination;
        fn Value::without_denomination(&self) -> u64; alias withoutDenomination;
        fn Value::value(&self) -> &u64;
    }
);
foreign_class!(
    #[derive(Display)]
    class MessageId {
        self_type MessageId;
        constructor MessageId::null() -> MessageId;
        private fn MessageId::to_string(&self) -> String;
        fn MessageId::fromString(str_rep: &str) -> MessageId {
            MessageId::from_str(str_rep).unwrap()
        }
    }
);

foreign_class!(
    #[derive(PartialEq)]
    class Message {
        self_type Message;
        private constructor = empty;
        private fn Message::eq(&self, o: &Message) -> bool; alias rustEq;
        fn Message::id(&self) -> MessageId;
        fn Message::version(&self) -> u64;
        fn Message::parents(&self) -> Vec<MessageId>;
        fn Message::payload_length(&self) -> usize; alias payloadLength;
        fn Message::payload(&self) -> Option<MessagePayload>;
        fn Message::timestamp(&self) -> DateTime<Utc>;
        fn Message::nonce(&self) -> u64;
        fn Message::confirmed(&self) -> Option<bool>;
        fn Message::broadcasted(&self) -> bool;
        fn Message::incoming(&self) -> bool;
        fn Message::value(&self) -> u64;
        fn Message::remainder_value(&self) -> u64; alias remainderValue;
    }
);

foreign_class!(
    #[derive(PartialEq, Display)]
    class Address {
        self_type Address;
        private constructor = empty;
        private fn Address::eq(&self, o: &Address) -> bool; alias rustEq;
        private fn Address::to_string(&self) -> String;
        fn Address::balance(&self) -> u64; alias getBalance;
        fn Address::readable(&self) -> String; alias getReadable;
        fn Address::address(&self) -> AddressWrapper;
    }
);

foreign_class!(
    class AddressWrapper {
        self_type AddressWrapper;
        private constructor = empty;
        fn AddressWrapper::to_bech32(&self) -> String; alias toBech32;
    }
);

foreign_class!(
    class AccountInitialiser{
        self_type AccountInitialiser;
        private constructor = empty;
        fn AccountInitialiser::signer_type(&mut self, signer_type_enum: AccountSignerType) -> AccountInitialiser; alias signerType;
        fn AccountInitialiser::alias(&mut self, alias: String) -> AccountInitialiser;
        fn AccountInitialiser::created_at(&mut self, created_at: DateTime<Local>) -> AccountInitialiser; alias createdAt;
        fn AccountInitialiser::messages(&mut self, messages: Vec<Message>) -> AccountInitialiser;
        fn AccountInitialiser::addresses(&mut self, addresses: Vec<Address>) -> AccountInitialiser;
        fn AccountInitialiser::skip_persistance(&mut self) -> AccountInitialiser; alias skipPersistance;
        fn AccountInitialiser::initialise(&mut self) -> Result<Account>;
    }
);

foreign_class!(
    class AccountBalance {
        self_type AccountBalance;
        private constructor = empty;
        fn AccountBalance::getTotal(&self) -> u64 {
            this.total
        }
        fn AccountBalance::getAvailable(&self) -> u64 {
            this.available
        }
        fn AccountBalance::getIncoming(&self) -> u64 {
            this.incoming
        }
        fn AccountBalance::getOutgoing(&self) -> u64 {
            this.outgoing
        }
    }
);

foreign_class!(
    class Account {
        self_type Account;
        private constructor = empty;
        fn Account::transfer(&mut self, transfer: Transfer) -> Result<Message>;
        fn Account::generate_address(&self) -> Result<Address>; alias generateAddress;
        fn Account::get_unused_address(&self) -> Result<Address>; alias getUnusedAddress;
        fn Account::is_latest_address_unused(&self) -> Result<bool>; alias isLatestAddressUnused;
        fn Account::latest_address(&self) -> Address; alias latestAddress;
        fn Account::set_alias(&self, alias: String) -> Result<()>; alias setAlias;
        fn Account::set_client_options(&self, options: ClientOptions) -> Result<()>; alias setClientOptions;
        fn Account::list_messages(&self, count: usize, from: usize, message_type: Option<MessageType>) -> Vec<Message>; alias listMessages;
        fn Account::list_spent_addresses(&self) -> Vec<Address>; alias listSpentAddresses;
        fn Account::list_unspent_addresses(&self) -> Vec<Address>; alias listUnspentAddresses;
        fn Account::get_message(&self, message_id: MessageId) -> Option<Message>; alias getMessage;
        fn Account::alias(&self) -> String;
        fn Account::balance(&self) -> AccountBalance;

        fn Account::id(&self) -> String;
        fn Account::created_at(&self) -> DateTime<Local>; alias createdAt;
        fn Account::last_synced_at(&self) -> Option<DateTime<Local>>; alias lastSyncedAt;
    }
);

foreign_class!(
    class Transfer {
        self_type Transfer;
        private constructor = empty;
        fn Transfer::builder(address: AddressWrapper, amount: u64) -> TransferBuilder;
    }
);

foreign_class!(
    class TransferBuilder {
        self_type TransferBuilder;
        constructor TransferBuilder::new(address: AddressWrapper, amount: u64) -> TransferBuilder;
        fn TransferBuilder::with_remainder_value_strategy(&mut self, strategy: RemainderValueStrategy) -> TransferBuilder; alias withRemainderValueStrategy;
        fn TransferBuilder::with_indexation(&mut self, indexation: IndexationPayload) -> TransferBuilder; alias withIndexation;
        fn TransferBuilder::finish(&self) -> Transfer;
    }
);

// Events

foreign_enum!(
    enum TransferProgressType {
        SYNCING_ACCOUNT = TransferProgressType::SyncingAccount,
        SELECTING_INPUTS = TransferProgressType::SelectingInputs,
        GENERATING_REMAINDER_DEPOST_ADDRESS = TransferProgressType::GeneratingRemainderDepositAddress,
        SIGNING_TRANSACTION = TransferProgressType::SigningTransaction,
        PERFORMING_POW = TransferProgressType::PerformingPoW,
        BROADCASTING = TransferProgressType::Broadcasting,
    }
);

foreign_enum!(
    enum StrongholdStatusType {
        UNLOCKED = StrongholdStatusType::Unlocked,
        LOCKED = StrongholdStatusType::Locked,
    }
);

foreign_class!(
    class StrongholdStatusEvent {
        self_type StrongholdStatusEvent;
        private constructor = empty;
        fn StrongholdStatusEvent::snapshot_path(&self) -> PathBuf; alias snapshotPath;
        fn StrongholdStatusEvent::status(&self) -> StrongholdStatusType;
        fn StrongholdStatusEvent::unlocked_duration(&self) -> Result<Duration>; alias unlockedDuration;
    }
);

foreign_class!(
    class AddressConsolidationNeededEvent {
        self_type WalletAddressConsolidationNeeded;
        private constructor = empty;
        fn WalletAddressConsolidationNeeded::accountId(&self) -> &str {
            this.account_id()
        }
        fn WalletAddressConsolidationNeeded::address(&self) -> AddressWrapper {
            this.address().clone()
        }
    }
);

foreign_class!(
    class TransactionEvent {
        self_type WalletTransactionEvent;
        private constructor = empty;
        fn WalletTransactionEvent::accountId(&self) -> &str {
            this.account_id()
        }
        fn WalletTransactionEvent::message(&self) -> Message {
            Message::new_with_internal(this.message().clone())
        }
    }
);

foreign_class!(
    class TransactionConfirmationChangeEvent {
        self_type WalletTransactionConfirmationChangeEvent;
        private constructor = empty;
        fn WalletTransactionConfirmationChangeEvent::accountId(&self) -> &str {
            this.account_id()
        }
        fn WalletTransactionConfirmationChangeEvent::message(&self) -> Message {
            Message::new_with_internal(this.message().clone())
        }
        fn WalletTransactionConfirmationChangeEvent::confirmed(&self) -> bool {
            *this.confirmed()
        }
    }
);

foreign_class!(
    class TransferProgressEvent {
        self_type WalletTransferProgress;
        private constructor = empty;
        fn WalletTransferProgress::accountId(&self) -> &str {
            this.account_id()
        }
        fn WalletTransferProgress::event(&self) -> TransferProgressType {
            this.event().clone()
        }
    }
);

foreign_class!(
    class BalanceChange {
        self_type BalanceChange;
        private constructor = empty;
        fn BalanceChange::isSpent(&self) -> bool {
            this.spent != 0
        }
        fn BalanceChange::spent(&self) -> u64 {
            this.spent
        }
        fn BalanceChange::received(&self) -> u64 {
            this.received
        }
    }
);

foreign_class!(
    class BalanceEvent {
        self_type WalletBalanceEvent;
        private constructor = empty;
        fn WalletBalanceEvent::accountId(&self) -> &str {
            this.account_id()
        }
        fn WalletBalanceEvent::address(&self) -> AddressWrapper {
            this.address().clone()
        }
        fn WalletBalanceEvent::balanceChange(&self) -> BalanceChange {
            this.balance_change().clone()
        }
    }
);

foreign_class!(
    class EventId {
        self_type EventId;
        private constructor = empty;
    }
);

foreign_callback!(callback ErrorListener {
    self_type ErrorListener + Send + 'static;
    onError = ErrorListener::on_error(&self, error: String);
});

foreign_callback!(callback NewTransactionListener {
    self_type NewTransactionListener + Send + 'static;
    onNewTransaction = NewTransactionListener::on_new_transaction(&self, event: WalletTransactionEvent);
});

foreign_callback!(callback ReattachTransactionListener {
    self_type ReattachTransactionListener + Send + 'static;
    onReattachTransaction = ReattachTransactionListener::on_reattachment(&self, event: WalletTransactionEvent);
});

foreign_callback!(callback BroadcastTransactionListener {
    self_type BroadcastTransactionListener + Send + 'static;
    onBroadcastTransaction = BroadcastTransactionListener::on_broadcast(&self, event: WalletTransactionEvent);
});

foreign_callback!(callback TransferProgressListener {
    self_type TransferProgressListener + Send + 'static;
    onTransferProgress = TransferProgressListener::on_transfer_progress(&self, event: WalletTransferProgress);
});

foreign_callback!(callback TransactionConfirmationChangeListener {
    self_type TransactionConfirmationChangeListener + Send + 'static;
    onConfirmationStateChange = TransactionConfirmationChangeListener::on_confirmation_state_change(&self, event: WalletTransactionConfirmationChangeEvent);
});

foreign_callback!(callback BalanceChangeListener {
    self_type BalanceChangeListener + Send + 'static;
    onBalanceChange = BalanceChangeListener::on_balance_change(&self, event: WalletBalanceEvent);
});

foreign_callback!(callback StrongholdStatusListener {
    self_type StrongholdStatusListener + Send + 'static;
    onStrongholdStatusChange = StrongholdStatusListener::on_stronghold_status_change(&self, event: StrongholdStatusEvent);
});

foreign_callback!(callback AddressConsolidationNeededListener {
    self_type AddressConsolidationNeededListener + Send + 'static;
    onAddressConsolidationNeeded = AddressConsolidationNeededListener::on_address_consolidation_needed(&self, event: WalletAddressConsolidationNeeded);
});

foreign_class!(
    class EventManager {
        self_type EventManager;
        private constructor = empty;
        fn EventManager::subscribe_errors(cb: Box<dyn ErrorListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_new_transaction(cb: Box<dyn NewTransactionListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_confirmation_state_change(cb: Box<dyn TransactionConfirmationChangeListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_reattachment(cb: Box<dyn ReattachTransactionListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_broadcast(cb: Box<dyn BroadcastTransactionListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_transfer_progress(cb: Box<dyn TransferProgressListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_balance_change(cb: Box<dyn BalanceChangeListener + Send + 'static>) -> EventId;
        fn EventManager::subscribe_stronghold_status_change(cb: Box<dyn StrongholdStatusListener + Send + 'static>) -> Result<EventId>;
        fn EventManager::subscribe_address_consolidation_needed(cb: Box<dyn AddressConsolidationNeededListener + Send + 'static>) -> Result<EventId>;
    
        fn EventManager::remove_error_listener(event: EventId);
        fn EventManager::remove_new_transaction_listener(event: EventId);
        fn EventManager::remove_confirmation_state_change_listener(event: EventId);
        fn EventManager::remove_reattachment_listener(event: EventId);
        fn EventManager::remove_broadcast_listener(event: EventId);
        fn EventManager::remove_transfer_progress_listener(event: EventId);
        fn EventManager::remove_balance_change_listener(event: EventId);
        fn EventManager::remove_stronghold_status_change_listener(event: EventId);
        fn EventManager::remove_address_consolidation_needed_listener(event: EventId);
    }
);

// Bee types wrapping
foreign_class!(
    #[derive(Display)]
    class MessagePayload {
        self_type MessagePayload;
        private constructor = empty;
        private fn MessagePayload::to_string(&self) -> String;
        fn MessagePayload::payload_type(&self) -> MessagePayloadType; alias payloadType;
        fn MessagePayload::get_as_indexation(&self) -> Option<IndexationPayload>; alias getAsIndexation;
        fn MessagePayload::get_as_milestone(&self) -> Option<MilestonePayload>; alias getAsMilestone;
    }
);

foreign_class!(
    class IndexationPayload {
        self_type IndexationPayload;
        private constructor = empty;
        fn IndexationPayload::new_with(index: &[u8], data: &[u8]) -> Result<IndexationPayload>;
        fn IndexationPayload::index(&self) -> &[u8];
        fn IndexationPayload::data(&self) -> &[u8];
    }
);

foreign_class!(
    class MilestonePayload {
        self_type MilestonePayload;
        private constructor = empty;
        fn MilestonePayload::id(&self) -> String;
        fn MilestonePayload::essence(&self) -> MilestonePayloadEssence;
        fn MilestonePayload::validate(&self, applicable_public_keys: &[String], min_threshold: usize) -> bool;
        //fn MilestonePayload::signatures(&self) -> Vec<Box<[u8]>>;
    }
);

foreign_class!(
    class MilestonePayloadEssence {
        self_type MilestonePayloadEssence;
        private constructor = empty;
        fn MilestonePayloadEssence::index(&self) -> u32;
        fn MilestonePayloadEssence::timestamp(&self) -> u64;
        fn MilestonePayloadEssence::parents(&self) -> Vec<MessageId>;
        fn MilestonePayloadEssence::merkle_proof(&self) -> Vec<u8>; alias merkleProof;
    }
);

// TransactionEssence

foreign_class!(
    class MessageTransactionPayload {
        self_type MessageTransactionPayload;
        private constructor = empty;
        fn MessageTransactionPayload::essence(&self) -> Essence;
        fn MessageTransactionPayload::unlock_blocks(&self) -> Vec<UnlockBlock>;
    }
);

foreign_class!(
    class Essence {
        self_type Essence;
        private constructor = empty;
        fn Essence::get_as_regular(&self) -> Option<RegularEssence>;
    }
);

foreign_class!(
    class RegularEssence {
        self_type RegularEssence;
        private constructor = empty;
        fn RegularEssence::inputs(&self) -> Vec<TransactionInput>;
        fn RegularEssence::outputs(&self) -> Vec<TransactionOutput>;
    }
);

foreign_class!(
    #[derive(Display)]
    class TransactionInput {
        self_type TransactionInput;
        private constructor = empty;
        private fn TransactionInput::to_string(&self) -> String;
        fn TransactionInput::kind(&self) -> InputKind;
    }
);

foreign_class!(
    #[derive(Display)]
    class TransactionOutput {
        self_type TransactionOutput;
        private constructor = empty;
        private fn TransactionOutput::to_string(&self) -> String;
        fn TransactionOutput::kind(&self) -> OutputKind;
    }
);

foreign_class!(
    #[derive(Display)]
    class UnlockBlock {
        self_type UnlockBlock;
        private constructor = empty;
        private fn UnlockBlock::to_string(&self) -> String;
        fn UnlockBlock::kind(&self) -> UnlockBlockKind;
    }
);

foreign_class!(
    class SignatureLockedSingleOutput {
        self_type SignatureLockedSingleOutput;
        private constructor = empty;
        fn SignatureLockedSingleOutput::amount(&self) -> u64;
    }
);

foreign_class!(
    class ReceiptPayload {
        self_type ReceiptPayload;
        private constructor = empty;
        fn ReceiptPayload::index(&self) -> u32;
        fn ReceiptPayload::last(&self) -> bool;
        fn ReceiptPayload::funds(&self) -> Vec<MigratedFundsEntry>;
        fn ReceiptPayload::amount(&self) -> u64;
    }
);

foreign_class!(
    class MigratedFundsEntry {
        self_type MigratedFundsEntry;
        private constructor = empty;
        fn MigratedFundsEntry::tail_transaction_hash(&self) -> Vec<u8>;
        fn MigratedFundsEntry::output(&self) -> SignatureLockedSingleOutput;
    }
);

foreign_class!(
    class TreasuryTransactionPayload {
        self_type TreasuryTransactionPayload;
        private constructor = empty;
        fn TreasuryTransactionPayload::input(&self) -> MessageId;
        fn TreasuryTransactionPayload::output(&self) -> u64;
    }
);
