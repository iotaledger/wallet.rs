---
title: Examples
description: Official IOTA Wallet Library Software Python examples.
image: /img/logo/wallet_light.png
keywords:
- account
- address
- python
- balance
- Chrysalis
---
import CodeBlock from '@theme/CodeBlock';
import create_account from  '!!raw-loader!./../../../../bindings/python/native/example/1-create-account.py';
import generate_address from  '!!raw-loader!./../../../../bindings/python/native/example/2-generate-address.py';
import check_balance from  '!!raw-loader!./../../../../bindings/python/native/example/3-check-balance.py';

This section will guide you through several examples using the python binding of the `wallet.rs` library. You can also find the code for the examples in the `/bindings/python/examples` folder in the [official GitHub repository](https://github.com/iotaledger/wallet.rs/tree/dev/bindings/python/examples).

All the examples in this section expect you to set your custom password  in the _.env_ file:

```bash
SH_PASSWORD="here is your super secure password"
```

### Accounts

The `wallet.rs` library uses a model of individual accounts to separate individual users and clients from each other. It is possible to generate multiple addresses for each account deterministically.

Each account is related to a specific IOTA network (mainnet or testnet), which is referenced by node properties such as node url.  In this example, the `Chrysalis` testnet balancer.

For more information about _client_options_ , please refer to [Wallet Python API Reference](api_reference.md#ClientOptions).

<CodeBlock className="language-python">
  {create_account}
</CodeBlock>

_Alias_ should be unique, and it can be any string that you see fit. The _alias_ is usually used to identify the account later on. Each account is also represented by an _index_ which is incremented by 1 every time new account is created.
Any account can be then referred to by its _index_ , _alias_ or one of its generated _addresses_ .

Once an account has been created, you retrieve an instance of it using the following methods:
- `get_account(account_id: str)`
- `get_accounts()` .


You can get an overview of all available accounts by running the following snippet:

```python
for acc in account_manager.get_accounts():
  print(f"Account alias: {acc.alias()}; network: {acc.bech32_hrp()}")
```

You can get and instance of a specific account using the `account_manager.get_account("ALIAS")`, replacing _"ALIAS"_ for the given alias:

```python
account = account_manager.get_account("Alice")
```

Several API calls can be performed via an _account_ instance.

:::info
It is a good practice to sync the given _account_ with the Tangle every time you work with an _account_ instance to retrieve the latest information available.  You can do this using the `account.sync()` method.  By default, `account.sync()` is performed automatically on `send` , `retry` , `reattach` and `promote` API calls.
:::

The most common methods of _account_ instance are:
* `account.alias()` : returns an alias of the given account.
* `account.addresses()` : returns list of addresses related to the account.
* `account.get_unused_address()` : returns a first unused address.
* `account.is_latest_address_unused()` : queries the Tangle and returns a _bool_ whether latest address was already used.
* `account.generate_address()` : generates a new address for the address index incremented by 1.
* `account.balance()` : returns the balance for the given account.
* `account.sync()` : syncs the account information with the tangle.

## Generating Address(es)

Each _account_ can have multiple _addresses_ . _Addresses_ are generated deterministically based on the _account_ and _address_ index. This means that the combination of _account_ and index uniquely identifies the given address.

There are two types of addresses, _internal_ and _public_ (external), and each set of addresses is independent of each other and has independent _index_ id.

* _Public_ addresses are created by `account.generateAddress()` and are indicated as `internal=false` (public)
* _Internal_ addresses are also called _change_ addresses. _Internal_ addresses are used to store the excess funds and are indicated as `internal=true`.

This approach is also known as a *BIP32 Hierarchical Deterministic wallet (HD Wallet)*.

:::info
The IOTA 1.5 (Chrysalis) network supports reusing addresses multiple times.
:::

You can use the following example to generate a new address via an instance of _account_ which was retrieved using an _account_manager_ instance:

<CodeBlock className="language-python">
  {generate_address}
</CodeBlock>

Example output:
```json
[{
        'address': {
            'inner': 'atoi1qzy79ew8x4hn4dsr0t3j8ce8hdwdrh8xzx85x2gkse6k0fx2jkyaqdgd2rn'
        },
        'balance': 0,
        'key_index': 0,
        'internal': False,
        'outputs': []
    },
    {
        'address': {
            'inner': 'atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg'
        },
        'balance': 0,
        'key_index': 1,
        'internal': False,
        'outputs': []
    }
]
```
There are two human-readable prefixes in IOTA 1.5 network: _iota_ (mainnet) and _atoi_ (testnet). If you take a close look at the addresses in the output, you will be able to notice that both of them start with _atoi_ , and are therefore testnet addresses.

You can find detailed information about generating addresses at the [Developer Guide to Chrysalis](https://chrysalis.docs.iota.org/guides/dev_guide#addresskey-space).

## Checking the Balance

Before we continue further, please visit the [IOTA testnet faucet service](https://faucet.chrysalis-devnet.iota.cafe/) and send some tokens to your testnet addresses.

![IOTA Faucet Service](/img/libraries/screenshot_faucet.png)

You can use the following example to sync your accounts and retrieve their balances.

<CodeBlock className="language-python">
  {check_balance}
</CodeBlock>

Example output:
```json
Total balance:
{
    'total': 10000000,
    'available': 10000000,
    'incoming': 10000000,
    'outgoing': 0
}

Balance per individual addresses:
[{
        'address': {
            'inner': 'atoi1qzy79ew8x4hn4dsr0t3j8ce8hdwdrh8xzx85x2gkse6k0fx2jkyaqdgd2rn'
        },
        'balance': 0,
        'key_index': 0,
        'internal': False,
        'outputs': []
    },
    {
        'address': {
            'inner': 'atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg'
        },
        'balance': 10000000,
        'key_index': 1,
        'internal': False,
        'outputs': [{
            'transaction_id': '1c88c91fe0a8eed074b5ccdfdad52403d7908d157b231ae1ef28b0e20ba14e8e',
            'block_id': 'f1575f984f7fda6e9b3e23e96ef3304fcd0ba4ce323af3920856a427fabe1abe',
            'index': 0,
            'amount': 10000000,
            'is_spent': False,
            'address': {
                'inner': 'atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg'
            }
        }]
    },
    {
        'address': {
            'inner': 'atoi1qpvnsgygzal4vkxhlc0ew7c6c6csnjr72x5rgn3txqswrsa2xfrec8v04f7'
        },
        'balance': 0,
        'key_index': 2,
        'internal': False,
        'outputs': []
    }
]
```
In the detailed view per individual addresses, there is also _outputs_ section.  The _outputs_ shows all the transactions (also known as _wallet block(s)_ ), which are related to that _address_, and therefore account for the balance.

You can also check the balance using the [Tangle Explorer](https://explorer.iota.org/devnet/addr/atoi1qzht4m2jt0q50lhlqa786pcx6vardm4xj8za72fezde6tj39acatq5zh2cg).

:::info
IOTA is based on _Unspent Transaction Output_ model. You can find a detailed explanation in the [Developer Guide to Chrysalis](https://chrysalis.docs.iota.org/guides/dev_guide#unspent-transaction-output-utxo).
:::

### Dust Protection

The network uses a [dust protection](https://chrysalis.docs.iota.org/guides/dev_guide#dust-protection) protocol to prevent malicious actors from spamming the network while also keeping track of the unspent amount ( _UTXO_ ).

:::info
“... micro-transaction below 1Mi of IOTA tokens can be sent to another address if there is already at least 1Mi on that address.
That's why we sent 1Mi in the last example to comply with the protection.”
:::

Dust protection also means you can't leave less than 1Mi on a spent address (leave a dust behind).
